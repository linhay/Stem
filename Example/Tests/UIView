

@available(iOS 2.0, *)
open class UIView : UIResponder, NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIFocusItem, UIFocusItemContainer, CALayerDelegate {

open class var layerClass: AnyClass { get }

public init(frame: CGRect)

public init?(coder aDecoder: NSCoder)

open var isUserInteractionEnabled: Bool

open var tag: Int

open var layer: CALayer { get }

@available(iOS 9.0, *)
open var canBecomeFocused: Bool { get }

@available(iOS 9.0, *)
open var isFocused: Bool { get }

@available(iOS 9.0, *)
open var semanticContentAttribute: UISemanticContentAttribute

@available(iOS 9.0, *)
open class func userInterfaceLayoutDirection(for attribute: UISemanticContentAttribute) -> UIUserInterfaceLayoutDirection

@available(iOS 10.0, *)
open class func userInterfaceLayoutDirection(for semanticContentAttribute: UISemanticContentAttribute, relativeTo layoutDirection: UIUserInterfaceLayoutDirection) -> UIUserInterfaceLayoutDirection

@available(iOS 10.0, *)
open var effectiveUserInterfaceLayoutDirection: UIUserInterfaceLayoutDirection { get }
}

extension UIView {
}
extension UIView {

open var frame: CGRect

open var bounds: CGRect

open var center: CGPoint

open var transform: CGAffineTransform

@available(iOS 4.0, *)
open var contentScaleFactor: CGFloat

open var isMultipleTouchEnabled: Bool

open var isExclusiveTouch: Bool

open func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView?

open func point(inside point: CGPoint, with event: UIEvent?) -> Bool

open func convert(_ point: CGPoint, to view: UIView?) -> CGPoint

open func convert(_ point: CGPoint, from view: UIView?) -> CGPoint

open func convert(_ rect: CGRect, to view: UIView?) -> CGRect

open func convert(_ rect: CGRect, from view: UIView?) -> CGRect

open var autoresizesSubviews: Bool

open var autoresizingMask: UIView.AutoresizingMask

open func sizeThatFits(_ size: CGSize) -> CGSize

open func sizeToFit()
}
extension UIView {

open var superview: UIView? { get }

open var subviews: [UIView] { get }

open var window: UIWindow? { get }

open func removeFromSuperview()

open func insertSubview(_ view: UIView, at index: Int)

open func exchangeSubview(at index1: Int, withSubviewAt index2: Int)

open func addSubview(_ view: UIView)

open func insertSubview(_ view: UIView, belowSubview siblingSubview: UIView)

open func insertSubview(_ view: UIView, aboveSubview siblingSubview: UIView)

open func bringSubviewToFront(_ view: UIView)

open func sendSubviewToBack(_ view: UIView)

open func didAddSubview(_ subview: UIView)

open func willRemoveSubview(_ subview: UIView)

open func willMove(toSuperview newSuperview: UIView?)

open func didMoveToSuperview()

open func willMove(toWindow newWindow: UIWindow?)

open func didMoveToWindow()

open func isDescendant(of view: UIView) -> Bool

open func viewWithTag(_ tag: Int) -> UIView?

open func setNeedsLayout()

open func layoutIfNeeded()

open func layoutSubviews()

@available(iOS 8.0, *)
open var layoutMargins: UIEdgeInsets

@available(iOS 11.0, *)
open var directionalLayoutMargins: NSDirectionalEdgeInsets

@available(iOS 8.0, *)
open var preservesSuperviewLayoutMargins: Bool

@available(iOS 11.0, *)
open var insetsLayoutMarginsFromSafeArea: Bool

@available(iOS 8.0, *)
open func layoutMarginsDidChange()

@available(iOS 11.0, *)
open var safeAreaInsets: UIEdgeInsets { get }

@available(iOS 11.0, *)
open func safeAreaInsetsDidChange()

@available(iOS 9.0, *)
open var layoutMarginsGuide: UILayoutGuide { get }

/// This content guide provides a layout area that you can use to place text and related content whose width should generally be constrained to a size that is easy for the user to read. This guide provides a centered region that you can place content within to get this behavior for this view.
@available(iOS 9.0, *)
open var readableContentGuide: UILayoutGuide { get }

@available(iOS 11.0, *)
open var safeAreaLayoutGuide: UILayoutGuide { get }
}
extension UIView {

open func draw(_ rect: CGRect)

open func setNeedsDisplay()

open func setNeedsDisplay(_ rect: CGRect)

open var clipsToBounds: Bool

@NSCopying open var backgroundColor: UIColor?

open var alpha: CGFloat

open var isOpaque: Bool

open var clearsContextBeforeDrawing: Bool

open var isHidden: Bool

open var contentMode: UIView.ContentMode

@available(iOS 8.0, *)
open var mask: UIView?

@available(iOS 7.0, *)
open var tintColor: UIColor!

@available(iOS 7.0, *)
open var tintAdjustmentMode: UIView.TintAdjustmentMode

@available(iOS 7.0, *)
open func tintColorDidChange()
}
extension UIView {

open class func beginAnimations(_ animationID: String?, context: UnsafeMutableRawPointer?)

open class func commitAnimations()

open class func setAnimationDelegate(_ delegate: Any?)

open class func setAnimationWillStart(_ selector: Selector?)

open class func setAnimationDidStop(_ selector: Selector?)

open class func setAnimationDuration(_ duration: TimeInterval)

open class func setAnimationDelay(_ delay: TimeInterval)

open class func setAnimationStart(_ startDate: Date)

open class func setAnimationCurve(_ curve: UIView.AnimationCurve)

open class func setAnimationRepeatCount(_ repeatCount: Float)

open class func setAnimationRepeatAutoreverses(_ repeatAutoreverses: Bool)

open class func setAnimationBeginsFromCurrentState(_ fromCurrentState: Bool)

open class func setAnimationTransition(_ transition: UIView.AnimationTransition, for view: UIView, cache: Bool)

open class func setAnimationsEnabled(_ enabled: Bool)

open class var areAnimationsEnabled: Bool { get }

@available(iOS 7.0, *)
open class func performWithoutAnimation(_ actionsWithoutAnimation: () -> Void)

@available(iOS 9.0, *)
open class var inheritedAnimationDuration: TimeInterval { get }
}
extension UIView {

@available(iOS 4.0, *)
open class func animate(withDuration duration: TimeInterval, delay: TimeInterval, options: UIView.AnimationOptions = [], animations: @escaping () -> Void, completion: ((Bool) -> Void)? = nil)

@available(iOS 4.0, *)
open class func animate(withDuration duration: TimeInterval, animations: @escaping () -> Void, completion: ((Bool) -> Void)? = nil)

@available(iOS 4.0, *)
open class func animate(withDuration duration: TimeInterval, animations: @escaping () -> Void)

@available(iOS 7.0, *)
open class func animate(withDuration duration: TimeInterval, delay: TimeInterval, usingSpringWithDamping dampingRatio: CGFloat, initialSpringVelocity velocity: CGFloat, options: UIView.AnimationOptions = [], animations: @escaping () -> Void, completion: ((Bool) -> Void)? = nil)

@available(iOS 4.0, *)
open class func transition(with view: UIView, duration: TimeInterval, options: UIView.AnimationOptions = [], animations: (() -> Void)?, completion: ((Bool) -> Void)? = nil)

@available(iOS 4.0, *)
open class func transition(from fromView: UIView, to toView: UIView, duration: TimeInterval, options: UIView.AnimationOptions = [], completion: ((Bool) -> Void)? = nil)

@available(iOS 7.0, *)
open class func perform(_ animation: UIView.SystemAnimation, on views: [UIView], options: UIView.AnimationOptions = [], animations parallelAnimations: (() -> Void)?, completion: ((Bool) -> Void)? = nil)
}
extension UIView {

@available(iOS 7.0, *)
open class func animateKeyframes(withDuration duration: TimeInterval, delay: TimeInterval, options: UIView.KeyframeAnimationOptions = [], animations: @escaping () -> Void, completion: ((Bool) -> Void)? = nil)

@available(iOS 7.0, *)
open class func addKeyframe(withRelativeStartTime frameStartTime: Double, relativeDuration frameDuration: Double, animations: @escaping () -> Void)
}
extension UIView {

@available(iOS 3.2, *)
open var gestureRecognizers: [UIGestureRecognizer]?

@available(iOS 3.2, *)
open func addGestureRecognizer(_ gestureRecognizer: UIGestureRecognizer)

@available(iOS 3.2, *)
open func removeGestureRecognizer(_ gestureRecognizer: UIGestureRecognizer)

@available(iOS 6.0, *)
open func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool
}
extension UIView {

/*! Begins applying `effect` to the receiver. The effect's emitted keyPath/value pairs will be
applied to the view's presentation layer.

Animates the transition to the motion effect's values using the present UIView animation
context. */
@available(iOS 7.0, *)
open func addMotionEffect(_ effect: UIMotionEffect)

/*! Stops applying `effect` to the receiver. Any affected presentation values will animate to
their post-removal values using the present UIView animation context. */
@available(iOS 7.0, *)
open func removeMotionEffect(_ effect: UIMotionEffect)

@available(iOS 7.0, *)
open var motionEffects: [UIMotionEffect]
}
extension NSLayoutConstraint {

public enum Axis : Int {

case horizontal

case vertical
}
}
extension UIView {

@available(iOS 6.0, *)
open var constraints: [NSLayoutConstraint] { get }

@available(iOS 6.0, *)
open func addConstraint(_ constraint: NSLayoutConstraint)

@available(iOS 6.0, *)
open func addConstraints(_ constraints: [NSLayoutConstraint])

@available(iOS 6.0, *)
open func removeConstraint(_ constraint: NSLayoutConstraint)

@available(iOS 6.0, *)
open func removeConstraints(_ constraints: [NSLayoutConstraint])
}
extension UIView {

@available(iOS 6.0, *)
open func updateConstraintsIfNeeded()

@available(iOS 6.0, *)
open func updateConstraints()

@available(iOS 6.0, *)
open func needsUpdateConstraints() -> Bool

@available(iOS 6.0, *)
open func setNeedsUpdateConstraints()
}
extension UIView {

@available(iOS 6.0, *)
open var translatesAutoresizingMaskIntoConstraints: Bool

@available(iOS 6.0, *)
open class var requiresConstraintBasedLayout: Bool { get }
}
extension UIView {

@available(iOS 6.0, *)
open func alignmentRect(forFrame frame: CGRect) -> CGRect

@available(iOS 6.0, *)
open func frame(forAlignmentRect alignmentRect: CGRect) -> CGRect

@available(iOS 6.0, *)
open var alignmentRectInsets: UIEdgeInsets { get }

@available(iOS, introduced: 6.0, deprecated: 9.0, message: "Override -viewForFirstBaselineLayout or -viewForLastBaselineLayout as appropriate, instead")
open func forBaselineLayout() -> UIView

@available(iOS 9.0, *)
open var forFirstBaselineLayout: UIView { get }

@available(iOS 9.0, *)
open var forLastBaselineLayout: UIView { get }

@available(iOS 6.0, *)
open var intrinsicContentSize: CGSize { get }

@available(iOS 6.0, *)
open func invalidateIntrinsicContentSize()

@available(iOS 6.0, *)
open func contentHuggingPriority(for axis: NSLayoutConstraint.Axis) -> UILayoutPriority

@available(iOS 6.0, *)
open func setContentHuggingPriority(_ priority: UILayoutPriority, for axis: NSLayoutConstraint.Axis)

@available(iOS 6.0, *)
open func contentCompressionResistancePriority(for axis: NSLayoutConstraint.Axis) -> UILayoutPriority

@available(iOS 6.0, *)
open func setContentCompressionResistancePriority(_ priority: UILayoutPriority, for axis: NSLayoutConstraint.Axis)
}

extension UIView {

/* The size fitting most closely to targetSize in which the receiver's subtree can be laid out while optimally satisfying the constraints. If you want the smallest possible size, pass UILayoutFittingCompressedSize; for the largest possible size, pass UILayoutFittingExpandedSize.
Also see the comment for UILayoutPriorityFittingSizeLevel.
*/
@available(iOS 6.0, *)
open func systemLayoutSizeFitting(_ targetSize: CGSize) -> CGSize // Equivalent to sending -systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority: with UILayoutPriorityFittingSizeLevel for both priorities.

@available(iOS 8.0, *)
open func systemLayoutSizeFitting(_ targetSize: CGSize, withHorizontalFittingPriority horizontalFittingPriority: UILayoutPriority, verticalFittingPriority: UILayoutPriority) -> CGSize
}

extension UIView {


/* UILayoutGuide objects owned by the receiver.
*/
@available(iOS 9.0, *)
open var layoutGuides: [UILayoutGuide] { get }


/* Adds layoutGuide to the receiver, passing the receiver in -setOwningView: to layoutGuide.
*/
@available(iOS 9.0, *)
open func addLayoutGuide(_ layoutGuide: UILayoutGuide)


/* Removes layoutGuide from the receiver, passing nil in -setOwningView: to layoutGuide.
*/
@available(iOS 9.0, *)
open func removeLayoutGuide(_ layoutGuide: UILayoutGuide)
}

extension UIView {

/* Constraint creation conveniences. See NSLayoutAnchor.h for details.
*/
@available(iOS 9.0, *)
open var leadingAnchor: NSLayoutXAxisAnchor { get }

@available(iOS 9.0, *)
open var trailingAnchor: NSLayoutXAxisAnchor { get }

@available(iOS 9.0, *)
open var leftAnchor: NSLayoutXAxisAnchor { get }

@available(iOS 9.0, *)
open var rightAnchor: NSLayoutXAxisAnchor { get }

@available(iOS 9.0, *)
open var topAnchor: NSLayoutYAxisAnchor { get }

@available(iOS 9.0, *)
open var bottomAnchor: NSLayoutYAxisAnchor { get }

@available(iOS 9.0, *)
open var widthAnchor: NSLayoutDimension { get }

@available(iOS 9.0, *)
open var heightAnchor: NSLayoutDimension { get }

@available(iOS 9.0, *)
open var centerXAnchor: NSLayoutXAxisAnchor { get }

@available(iOS 9.0, *)
open var centerYAnchor: NSLayoutYAxisAnchor { get }

@available(iOS 9.0, *)
open var firstBaselineAnchor: NSLayoutYAxisAnchor { get }

@available(iOS 9.0, *)
open var lastBaselineAnchor: NSLayoutYAxisAnchor { get }
}

// Debugging

/* Everything in this section should be used in debugging only, never in shipping code.  These methods may not exist in the future - no promises.
*/
extension UIView {


/* This returns a list of all the constraints that are affecting the current location of the receiver.  The constraints do not necessarily involve the receiver, they may affect the frame indirectly.
Pass UILayoutConstraintAxisHorizontal for the constraints affecting [self center].x and CGRectGetWidth([self bounds]), and UILayoutConstraintAxisVertical for the constraints affecting[self center].y and CGRectGetHeight([self bounds]).
*/
@available(iOS 6.0, *)
open func constraintsAffectingLayout(for axis: NSLayoutConstraint.Axis) -> [NSLayoutConstraint]


/* If there aren't enough constraints in the system to uniquely determine layout, we say the layout is ambiguous.  For example, if the only constraint in the system was x = y + 100, then there are lots of different possible values for x and y.  This situation is not automatically detected by UIKit, due to performance considerations and details of the algorithm used for layout.
The symptom of ambiguity is that views sometimes jump from place to place, or possibly are just in the wrong place.
-hasAmbiguousLayout runs a check for whether there is another center and bounds the receiver could have that could also satisfy the constraints.
-exerciseAmbiguousLayout does more.  It randomly changes the view layout to a different valid layout.  Making the UI jump back and forth can be helpful for figuring out where you're missing a constraint.
*/

@available(iOS 6.0, *)
open var hasAmbiguousLayout: Bool { get }


@available(iOS 6.0, *)
open func exerciseAmbiguityInLayout()
}

/* Everything in this section should be used in debugging only, never in shipping code.  These methods may not exist in the future - no promises.
*/
extension UILayoutGuide {


/* This returns a list of all the constraints that are affecting the current location of the receiver.  The constraints do not necessarily involve the receiver, they may affect the frame indirectly.
Pass UILayoutConstraintAxisHorizontal for the constraints affecting [self center].x and CGRectGetWidth([self bounds]), and UILayoutConstraintAxisVertical for the constraints affecting[self center].y and CGRectGetHeight([self bounds]).
*/
@available(iOS 10.0, *)
open func constraintsAffectingLayout(for axis: NSLayoutConstraint.Axis) -> [NSLayoutConstraint]


/* If there aren't enough constraints in the system to uniquely determine layout, we say the layout is ambiguous.  For example, if the only constraint in the system was x = y + 100, then there are lots of different possible values for x and y.  This situation is not automatically detected by UIKit, due to performance considerations and details of the algorithm used for layout.
The symptom of ambiguity is that views sometimes jump from place to place, or possibly are just in the wrong place.
-hasAmbiguousLayout runs a check for whether there is another center and bounds the receiver could have that could also satisfy the constraints.
*/

@available(iOS 10.0, *)
open var hasAmbiguousLayout: Bool { get }
}

extension UIView {

@available(iOS 6.0, *)
open var restorationIdentifier: String?

@available(iOS 6.0, *)
open func encodeRestorableState(with coder: NSCoder)

@available(iOS 6.0, *)
open func decodeRestorableState(with coder: NSCoder)
}

extension UIView {

/*
* When requesting a snapshot, 'afterUpdates' defines whether the snapshot is representative of what's currently on screen or if you wish to include any recent changes before taking the snapshot.

If called during layout from a committing transaction, snapshots occurring after the screen updates will include all changes made, regardless of when the snapshot is taken and the changes are made. For example:

- (void)layoutSubviews {
UIView *snapshot = [self snapshotViewAfterScreenUpdates:YES];
self.alpha = 0.0;
}

The snapshot will appear to be empty since the change in alpha will be captured by the snapshot. If you need to animate the view during layout, animate the snapshot instead.

* Creating snapshots from existing snapshots (as a method to duplicate, crop or create a resizable variant) is supported. In cases where many snapshots are needed, creating a snapshot from a common superview and making subsequent snapshots from it can be more performant. Please keep in mind that if 'afterUpdates' is YES, the original snapshot is committed and any changes made to it, not the view originally snapshotted, will be included.
*/
@available(iOS 7.0, *)
open func snapshotView(afterScreenUpdates afterUpdates: Bool) -> UIView?

@available(iOS 7.0, *)
open func resizableSnapshotView(from rect: CGRect, afterScreenUpdates afterUpdates: Bool, withCapInsets capInsets: UIEdgeInsets) -> UIView? // Resizable snapshots will default to stretching the center

// Use this method to render a snapshot of the view hierarchy into the current context. Returns NO if the snapshot is missing image data, YES if the snapshot is complete. Calling this method from layoutSubviews while the current transaction is committing will capture what is currently displayed regardless if afterUpdates is YES.
@available(iOS 7.0, *)
open func drawHierarchy(in rect: CGRect, afterScreenUpdates afterUpdates: Bool) -> Bool
}
